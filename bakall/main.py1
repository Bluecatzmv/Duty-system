from fastapi import FastAPI, Depends, HTTPException, status, UploadFile, File
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from sqlmodel import Session, select, create_engine, SQLModel
from sqlalchemy.orm import selectinload
from contextlib import asynccontextmanager
from typing import Annotated, List, Optional
from io import BytesIO 
from datetime import timedelta, date, datetime
import requests
import openpyxl
from collections import defaultdict
from jose import JWTError, jwt
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger

from models import User, Role, UserRead, UserCreate, Schedule, ScheduleRead, DutyType, Staff, Holiday, HolidayType, Redemption, SystemConfig
from auth import verify_password, create_access_token, get_password_hash, ACCESS_TOKEN_EXPIRE_MINUTES, SECRET_KEY, ALGORITHM

# ================= 配置区 =================
sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"
connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)

scheduler = AsyncIOScheduler()

# ================= 数据库初始化 =================
def create_db_and_tables():
    SQLModel.metadata.create_all(engine)
    with Session(engine) as session:
        admin = session.exec(select(User).where(User.username == "admin")).first()
        if not admin:
            super_admin = User(username="admin", real_name="超级管理员", password_hash=get_password_hash("admin123"), role=Role.SUPER_ADMIN)
            session.add(super_admin)
            session.commit()

# ================= 辅助函数 =================
def get_session():
    with Session(engine) as session:
        yield session

def core_send_notification():
    with Session(engine) as session:
        url_obj = session.get(SystemConfig, "wecom_url")
        tpl_obj = session.get(SystemConfig, "wecom_template")
        if not url_obj or not url_obj.value:
            print("【定时任务】未配置 Webhook，跳过发送")
            return {"status": "error", "message": "未配置 Webhook"}
        template = tpl_obj.value if tpl_obj and tpl_obj.value else "今日值班：{leader}，技术：{tech}，机动：{mobile}"
        today = date.today()
        two_days_ago = today - timedelta(days=2)
        leader_sch = session.exec(select(Schedule).where(Schedule.date == today, Schedule.duty_type == DutyType.LEADER)).first()
        leader_name = leader_sch.staff_name if leader_sch else "无"
        tech_sch = session.exec(select(Schedule).where(Schedule.date == today, Schedule.duty_type == DutyType.TECH)).first()
        tech_name = tech_sch.staff_name if tech_sch else "无"
        mobile_sch = session.exec(select(Schedule).where(Schedule.date == two_days_ago, Schedule.duty_type == DutyType.TECH)).first()
        mobile_name = mobile_sch.staff_name if mobile_sch else "无"
        try:
            content = template.replace("{leader}", leader_name).replace("{tech}", tech_name).replace("{mobile}", mobile_name).replace("{mobile_date}", str(two_days_ago))
        except: content = f"模版解析错误"
        payload = {"msgtype": "markdown", "markdown": {"content": content}}
        try:
            requests.post(url_obj.value, json=payload, timeout=5)
            print(f"【定时任务】通知已发送：{today}")
            return {"status": "success"}
        except Exception as e:
            print(f"【定时任务】发送异常：{e}")
            return {"status": "error", "message": str(e)}

@asynccontextmanager
async def lifespan(app: FastAPI):
    create_db_and_tables()
    scheduler.start()
    with Session(engine) as session:
        time_obj = session.get(SystemConfig, "wecom_time")
        if time_obj and time_obj.value:
            try:
                h, m = map(int, time_obj.value.split(":"))
                scheduler.add_job(core_send_notification, CronTrigger(hour=h, minute=m), id="daily_notify", replace_existing=True)
                print(f"已加载定时任务：每天 {time_obj.value} 发送")
            except: print("定时任务时间格式错误")
    yield
    scheduler.shutdown()

app = FastAPI(lifespan=lifespan)
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)], session: Session = Depends(get_session)):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None: raise HTTPException(status_code=401)
    except: raise HTTPException(status_code=401)
    user = session.exec(select(User).where(User.username == username)).first()
    if not user: raise HTTPException(status_code=401)
    return user

async def check_super_admin(user: User = Depends(get_current_user)):
    if user.role != Role.SUPER_ADMIN: raise HTTPException(status_code=403, detail="需要超级管理员权限")
    return user

# ================= 认证 =================
@app.post("/token")
async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()], session: Session = Depends(get_session)):
    user = session.exec(select(User).where(User.username == form_data.username)).first()
    if not user or not verify_password(form_data.password, user.password_hash): raise HTTPException(status_code=400, detail="账号或密码错误")
    token = create_access_token(data={"sub": user.username, "role": user.role}, expires_delta=timedelta(minutes=480))
    return {"access_token": token, "token_type": "bearer", "role": user.role}

# ================= 1. 进阶统计接口 (NEW) =================
# ... (前面的代码保持不变)

@app.get("/stats/advanced")
async def get_advanced_stats(year: int, session: Session = Depends(get_session)):
    start_date = date(year, 1, 1)
    end_date = date(year + 1, 1, 1)
    
    # 1. 获取所有节假日定义
    holidays = session.exec(select(Holiday).where(Holiday.date >= start_date, Holiday.date < end_date)).all()
    holiday_set = {h.date for h in holidays if h.type == HolidayType.HOLIDAY}
    
    # 2. 获取所有排班
    schedules = session.exec(
        select(Schedule).where(Schedule.date >= start_date, Schedule.date < end_date).options(selectinload(Schedule.staff))
    ).all()
    
    # --- 模块一：周番矩阵 (排除节假日 & 按天去重) ---
    weekday_matrix = {} 
    
    # 新增：用于去重的集合，存 (name, date)
    processed_duties = set()
    
    for s in schedules:
        # 只统计技术中心
        if not s.staff or s.staff.department != "技术中心": continue
        
        # 排除法定节假日
        if s.date in holiday_set: continue
        
        # 核心修复：去重检查
        # 如果 (姓名, 日期) 已经处理过，说明这一天已经计入过该人的星期统计了，跳过
        unique_key = (s.staff_name, s.date)
        if unique_key in processed_duties:
            continue
            
        # 标记为已处理
        processed_duties.add(unique_key)
        
        name = s.staff_name
        if name not in weekday_matrix:
            weekday_matrix[name] = [0] * 7 
        
        # 统计该星期几
        weekday_idx = s.date.weekday()
        weekday_matrix[name][weekday_idx] += 1
        
    # 转换为前端好用的列表格式，并按总数倒序
    matrix_list = []
    for name, counts in weekday_matrix.items():
        matrix_list.append({"name": name, "counts": counts, "total": sum(counts)})
    matrix_list.sort(key=lambda x: x["total"], reverse=True)
    
    # --- 模块二：节假日 C 位分析 (保持不变) ---
    sorted_holidays = sorted(list(holiday_set))
    holiday_groups = []
    if sorted_holidays:
        current_group = [sorted_holidays[0]]
        for i in range(1, len(sorted_holidays)):
            if sorted_holidays[i] - sorted_holidays[i-1] == timedelta(days=1):
                current_group.append(sorted_holidays[i])
            else:
                holiday_groups.append(current_group)
                current_group = [sorted_holidays[i]]
        holiday_groups.append(current_group)
    
    holiday_analysis = []
    total_holiday_days = len(holiday_set)
    
    # 这里也需要去重统计人次，否则“节假日值班总人次”也会虚高
    # 使用 set 来统计 (date, name) 组合的数量
    holiday_duty_unique_set = set()
    
    schedule_map = defaultdict(list)
    for s in schedules:
        if s.staff and s.staff.department == "技术中心":
            # 记录排班用于C位展示（展示时不去重没关系，因为会显示多个标签）
            # 但为了防止界面上同一个人名字出现两次，这里也可以去重
            if s.staff_name not in schedule_map[s.date]:
                schedule_map[s.date].append(s.staff_name)
            
            if s.date in holiday_set:
                holiday_duty_unique_set.add((s.date, s.staff_name))

    total_holiday_duty_count = len(holiday_duty_unique_set)

    for group in holiday_groups:
        length = len(group)
        if length == 0: continue
        
        center_dates = set()
        if length % 2 != 0:
            center_idx = length // 2
            center_dates.add(group[center_idx])
        else:
            center_idx1 = length // 2 - 1
            center_idx2 = length // 2
            center_dates.add(group[center_idx1])
            center_dates.add(group[center_idx2])
            
        group_details = []
        for d in group:
            duty_names = schedule_map.get(d, [])
            is_center = d in center_dates
            group_details.append({
                "date": d,
                "names": duty_names,
                "is_center": is_center
            })
            
        start_str = group[0].strftime("%m.%d")
        end_str = group[-1].strftime("%m.%d")
        
        holiday_analysis.append({
            "name": f"{start_str}-{end_str} 假期",
            "length": length,
            "days": group_details
        })
        
    return {
        "weekday_stats": matrix_list,
        "holiday_stats": {
            "total_days": total_holiday_days,
            "total_duties": total_holiday_duty_count,
            "groups": holiday_analysis
        }
    }

# ... (后面的代码保持不变)



# ================= 原有接口保持不变 =================
class WeComConfigRequest(SQLModel):
    webhook_url: str; message_template: str; daily_time: Optional[str] = None
@app.get("/config/wecom")
async def get_wecom_config(user: User = Depends(get_current_user), session: Session = Depends(get_session)):
    if user.role not in [Role.ADMIN, Role.SUPER_ADMIN]: raise HTTPException(status_code=403)
    url_obj = session.get(SystemConfig, "wecom_url"); tpl_obj = session.get(SystemConfig, "wecom_template"); time_obj = session.get(SystemConfig, "wecom_time")
    return {"webhook_url": url_obj.value if url_obj else "", "message_template": tpl_obj.value if tpl_obj else "", "daily_time": time_obj.value if time_obj else None}
@app.post("/config/wecom")
async def save_wecom_config(req: WeComConfigRequest, user: User = Depends(get_current_user), session: Session = Depends(get_session)):
    if user.role not in [Role.ADMIN, Role.SUPER_ADMIN]: raise HTTPException(status_code=403)
    url_obj = session.get(SystemConfig, "wecom_url"); 
    if not url_obj: url_obj = SystemConfig(key="wecom_url", value="")
    url_obj.value = req.webhook_url; session.add(url_obj)
    tpl_obj = session.get(SystemConfig, "wecom_template")
    if not tpl_obj: tpl_obj = SystemConfig(key="wecom_template", value="")
    tpl_obj.value = req.message_template; session.add(tpl_obj)
    time_obj = session.get(SystemConfig, "wecom_time")
    if not time_obj: time_obj = SystemConfig(key="wecom_time", value="")
    if req.daily_time:
        time_obj.value = req.daily_time; session.add(time_obj)
        try: h, m = map(int, req.daily_time.split(":")); scheduler.add_job(core_send_notification, CronTrigger(hour=h, minute=m), id="daily_notify", replace_existing=True)
        except: raise HTTPException(status_code=400, detail="时间格式错误")
    else:
        time_obj.value = ""; session.add(time_obj)
        if scheduler.get_job("daily_notify"): scheduler.remove_job("daily_notify")
    session.commit(); return {"message": "配置已保存，定时任务已更新"}
@app.post("/notify/send")
async def send_daily_notification_manual(user: User = Depends(get_current_user)):
    if user.role not in [Role.ADMIN, Role.SUPER_ADMIN]: raise HTTPException(status_code=403)
    return core_send_notification()
@app.get("/compensatory/overview")
async def get_compensatory_overview(year: int, session: Session = Depends(get_session)):
    start_date = date(year, 1, 1); end_date = date(year + 1, 1, 1)
    schedules = session.exec(select(Schedule).where(Schedule.date >= start_date, Schedule.date < end_date).options(selectinload(Schedule.staff))).all()
    stats = {}
    for s in schedules:
        if not s.staff or s.staff.department != "技术中心": continue
        name = s.staff_name
        if name not in stats: stats[name] = {"name": name, "total_earned_days": 0, "total_redeemed_days": 0, "balance": 0, "processed_dates": set()}
        if s.date not in stats[name]["processed_dates"]: stats[name]["total_earned_days"] += 2; stats[name]["processed_dates"].add(s.date)
        stats[name]["total_redeemed_days"] += s.redeemed_count
    result = []
    for name, data in stats.items(): data["balance"] = data["total_earned_days"] - data["total_redeemed_days"]; del data["processed_dates"]; result.append(data)
    return sorted(result, key=lambda x: x["balance"], reverse=True)
@app.get("/compensatory/calendar/{staff_name}")
async def get_compensatory_calendar(staff_name: str, year: int, session: Session = Depends(get_session)):
    start_date = date(year, 1, 1); end_date = date(year + 1, 1, 1)
    schedules = session.exec(select(Schedule).where(Schedule.date >= start_date, Schedule.date < end_date, Schedule.staff_name == staff_name).options(selectinload(Schedule.redemptions))).all()
    date_groups = defaultdict(list)
    for s in schedules: date_groups[s.date].append(s)
    events = []; quota_list = []
    for day_date in sorted(date_groups.keys()):
        sibs = date_groups[day_date]
        total_redeemed_on_day = sum(s.redeemed_count for s in sibs)
        first_s = sibs[0]
        events.append({"title": "值班 (+2)", "start": day_date, "color": "#2080f0", "type": "duty", "schedule_id": first_s.id})
        remaining = 2 - total_redeemed_on_day
        if remaining > 0: quota_list.append({"id": first_s.id, "date": day_date, "remaining": remaining})
        for s in sibs:
            for r in s.redemptions:
                events.append({"title": "已休", "start": r.redeem_date, "color": "#18a058", "type": "leave", "redemption_id": r.id, "from_date": day_date})
    return {"events": events, "quota_list": quota_list}
class RedeemRequest(SQLModel):
    staff_name: str; redeem_date: date; schedule_id: int
@app.post("/compensatory/redeem")
async def redeem_schedule(req: RedeemRequest, session: Session = Depends(get_session)):
    sch = session.get(Schedule, req.schedule_id)
    if not sch: raise HTTPException(status_code=404, detail="额度来源不存在")
    siblings = session.exec(select(Schedule).where(Schedule.staff_name == sch.staff_name, Schedule.date == sch.date)).all()
    total_used = sum(s.redeemed_count for s in siblings)
    if total_used >= 2: raise HTTPException(status_code=400, detail="该值班日期的调休额度(2天)已全部用完")
    redemption = Redemption(schedule_id=sch.id, redeem_date=req.redeem_date)
    sch.redeemed_count += 1
    session.add(redemption); session.add(sch); session.commit()
    return {"message": "登记成功"}
@app.delete("/compensatory/redeem/{redemption_id}")
async def cancel_redeem(redemption_id: int, session: Session = Depends(get_session)):
    r = session.get(Redemption, redemption_id)
    if not r: raise HTTPException(status_code=404)
    sch = session.get(Schedule, r.schedule_id)
    if sch: sch.redeemed_count -= 1; session.add(sch)
    session.delete(r); session.commit()
    return {"message": "已撤销"}
@app.get("/users/", response_model=List[UserRead])
async def get_all_users(user: User = Depends(check_super_admin), session: Session = Depends(get_session)):
    return session.exec(select(User)).all()
@app.post("/users/", response_model=UserRead)
async def create_user(new_user: UserCreate, user: User = Depends(check_super_admin), session: Session = Depends(get_session)):
    if session.exec(select(User).where(User.username == new_user.username)).first(): raise HTTPException(status_code=400)
    db_user = User(username=new_user.username, real_name=new_user.real_name, password_hash=get_password_hash(new_user.password), role=new_user.role)
    session.add(db_user); session.commit(); session.refresh(db_user); return db_user
@app.delete("/users/{user_id}")
async def delete_user(user_id: int, user: User = Depends(check_super_admin), session: Session = Depends(get_session)):
    target = session.get(User, user_id); 
    if target and target.username != "admin": session.delete(target); session.commit()
    return {"message": "ok"}
@app.get("/holidays/", response_model=List[Holiday])
async def get_holidays(year: int, month: int, session: Session = Depends(get_session)):
    start = date(year, month, 1); end = date(year+1, 1, 1) if month==12 else date(year, month+1, 1)
    return session.exec(select(Holiday).where(Holiday.date >= start, Holiday.date < end)).all()
class HolidayBatchRequest(SQLModel):
    start_date: date; end_date: date; name: str; type: HolidayType
@app.post("/holidays/batch")
async def create_holiday_batch(req: HolidayBatchRequest, user: User = Depends(get_current_user), session: Session = Depends(get_session)):
    if req.start_date > req.end_date: raise HTTPException(status_code=400)
    curr = req.start_date; count = 0
    while curr <= req.end_date:
        ext = session.exec(select(Holiday).where(Holiday.date == curr)).first()
        if ext: ext.name=req.name; ext.type=req.type; session.add(ext)
        else: session.add(Holiday(date=curr, name=req.name, type=req.type))
        curr += timedelta(days=1); count += 1
    session.commit(); return {"msg": "ok"}
@app.delete("/holidays/{holiday_id}")
async def delete_holiday(h_id: int, user: User = Depends(get_current_user), session: Session = Depends(get_session)):
    t = session.get(Holiday, h_id); 
    if t: session.delete(t); session.commit()
    return {"msg": "ok"}
@app.post("/contacts/import")
async def import_contacts(file: UploadFile = File(...), user: User = Depends(get_current_user), session: Session = Depends(get_session)):
    c = await file.read(); wb = openpyxl.load_workbook(BytesIO(c)); sheet = wb.active
    names = set(); u=0; cr=0
    for r in sheet.iter_rows(min_row=2, values_only=True):
        n=r[0]; d=r[1]; p=str(r[2]) if r[2] else ""; 
        if not n: continue
        n=n.strip(); names.add(n)
        s = session.exec(select(Staff).where(Staff.real_name == n)).first()
        if s: s.department=d; s.phone=p; session.add(s); u+=1
        else: session.add(Staff(real_name=n, department=d, phone=p)); cr+=1
    all_s = session.exec(select(Staff)).all()
    cd=0
    for s in all_s:
        if s.real_name not in names: session.delete(s); cd+=1
    session.commit(); return {"msg": f"Add {cr}, Upd {u}, Del {cd}"}
@app.get("/schedules/", response_model=List[ScheduleRead])
async def read_schedules(year: int, month: int, session: Session = Depends(get_session)):
    start = date(year, month, 1); end = date(year+1, 1, 1) if month==12 else date(year, month+1, 1)
    s = session.exec(select(Schedule).where(Schedule.date >= start, Schedule.date < end).options(selectinload(Schedule.staff))).all()
    res = []
    for i in s: res.append(ScheduleRead(id=i.id, date=i.date, duty_type=i.duty_type, staff_name=i.staff_name, staff_phone=i.staff.phone if i.staff else "", redeemed_count=i.redeemed_count))
    return res
@app.put("/schedules/{sid}")
async def update_schedule(sid: int, d: ScheduleRead, u: User = Depends(get_current_user), s: Session = Depends(get_session)):
    db = s.get(Schedule, sid)
    if not db: raise HTTPException(404)
    dt = d.date
    if isinstance(dt, str): dt = datetime.strptime(dt, "%Y-%m-%d").date()
    db.date = dt; db.duty_type = d.duty_type; 
    sn = d.staff_name.strip()
    st = s.exec(select(Staff).where(Staff.real_name == sn)).first()
    if not st: st = Staff(real_name=sn, phone=d.staff_phone); s.add(st); s.commit(); s.refresh(st)
    else: 
        if d.staff_phone and st.phone != d.staff_phone: st.phone = d.staff_phone; s.add(st)
    db.staff_name = sn; db.staff_id = st.id; s.add(db); s.commit(); return {"msg": "ok"}
@app.delete("/schedules/{sid}")
async def delete_schedule(sid: int, u: User = Depends(get_current_user), s: Session = Depends(get_session)):
    t = s.get(Schedule, sid); 
    if t: s.delete(t); s.commit()
    return {"msg": "ok"}
@app.post("/schedules/import_excel")
async def import_excel(file: UploadFile = File(...), u: User = Depends(get_current_user), s: Session = Depends(get_session)):
    c = await file.read(); wb = openpyxl.load_workbook(BytesIO(c)); sheet = wb.active; cnt=0
    cm = { 2: DutyType.LEADER, 3: DutyType.TECH, 4: DutyType.DAY, 5: DutyType.NIGHT, 6: DutyType.NIGHT_TRAINEE, 7: DutyType.UPDATE, 8: DutyType.TRAINEE }
    for r in sheet.iter_rows(min_row=2, values_only=True):
        dv = r[0]; 
        if not dv: continue
        sd = dv if isinstance(dv, (datetime, date)) else datetime.strptime(dv, "%Y-%m-%d").date()
        for idx, dt in cm.items():
            if idx >= len(r): break
            nm = r[idx]
            if nm and str(nm).strip():
                nm = str(nm).strip()
                st = s.exec(select(Staff).where(Staff.real_name == nm)).first()
                if not st: st = Staff(real_name=nm); s.add(st); s.commit(); s.refresh(st)
                ext = s.exec(select(Schedule).where(Schedule.date == sd, Schedule.duty_type == dt)).first()
                if ext: ext.staff_name = nm; ext.staff_id = st.id; s.add(ext)
                else: s.add(Schedule(date=sd, staff_name=nm, staff_id=st.id, duty_type=dt))
                cnt += 1
    s.commit(); return {"msg": f"Import {cnt}"}
@app.get("/stats/yearly")
async def get_yearly_stats(year: int, session: Session = Depends(get_session)):
    start_date = date(year, 1, 1); end_date = date(year + 1, 1, 1)
    holidays_query = session.exec(select(Holiday).where(Holiday.date >= start_date, Holiday.date < end_date)).all()
    holiday_set = {h.date for h in holidays_query if h.type == HolidayType.HOLIDAY}
    workday_set = {h.date for h in holidays_query if h.type == HolidayType.WORKDAY}
    schedules = session.exec(select(Schedule).where(Schedule.date >= start_date, Schedule.date < end_date).options(selectinload(Schedule.staff))).all()
    stats = {}
    for s in schedules:
        if not s.staff or s.staff.department != "技术中心": continue
        name = s.staff_name
        if name not in stats: stats[name] = {"name": name, "worked_dates": set(), "total": 0, "holiday_count": 0, "weekend_count": 0, "weekday_count": 0, "months": [0] * 12, "details": []}
        is_holiday = s.date in holiday_set
        is_weekend = (s.date.weekday() >= 5) and (s.date not in workday_set)
        if s.date not in stats[name]["worked_dates"]:
            if is_holiday: stats[name]["holiday_count"] += 1
            elif is_weekend: stats[name]["weekend_count"] += 1
            else: stats[name]["weekday_count"] += 1
            stats[name]["months"][s.date.month - 1] += 1
            stats[name]["details"].append({"date": s.date, "type": s.duty_type, "is_holiday": is_holiday, "is_weekend": is_weekend})
        stats[name]["worked_dates"].add(s.date)
    result_list = []
    for name, data in stats.items():
        data["total"] = len(data["worked_dates"]); del data["worked_dates"]; data["details"].sort(key=lambda x: x["date"]); result_list.append(data)
    result_list.sort(key=lambda x: x["total"], reverse=True)
    return result_list
